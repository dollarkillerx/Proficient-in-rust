# 生命周期
- 1. RUST每一个引用都会有其生命周期   也就是引用的有效作用域  大部分时候生命周期都是隐含并可以推断的
- 2. 生命周期主要目标是避免垂悬引用
- 3. RUST编译器使用借用检测器来检查生命周期是否有效

### 注: 生命周期注解不会改变生命周期 只会检查相组合的生命周期 有效作用于长度

### 方法生命周期
``` 
pub fn test1() {
    let s1 = String::from("abcs");
    let s2 = String::from("ab");

    let c = str_bj(s1.as_str(),s2.as_str());
    println!("c: {}",c);
}

fn str_bj<'a>(x:&'a str,y:&'a str) -> &'a str {  // 这里不知道 传出是a还是b  所以要标注生命周期
    if x.len() > y.len() {
        return x
    }
    y
}
```

### [重要] 编译器生命周期省略
- 1. 每个引用的参数都有它自己的生命周期。例如
    - 一个引用参数的函数 其中有一个生命周期: `fn foo<'a>(x: &'a32)`
    - 两个引用参数的函数  则有两个生命周期: `fn foo<'a,'b>(x:&'a i32,b:&'b u32)`
- 2. 如果只有一个输入生命周期参数，那莫它被赋予所有输出生命周期参数: 
    - `fn foo(x: &i32) -> &i32` 等价于 `fn foo<'a>(x: &'a i32) ->&'a i32 `
- 3. 如该方法有多个输入生命周期参数，不过其中之一因为方法的缘故为&self 或者为&mut self,那莫self的生命周期被赋予所有输出的生命周期参数
    - `fn function(&self,x: &str,y: &str,...) -> &str`